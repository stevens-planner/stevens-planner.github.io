{"ast":null,"code":"\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _immutabilityHelper = _interopRequireDefault(require(\"immutability-helper\"));\n\nconst LaneHelper = {\n  initialiseLanes: (state, {\n    lanes\n  }) => {\n    const newLanes = lanes.map(lane => {\n      lane.currentPage = 1;\n      lane.cards && lane.cards.forEach(c => c.laneId = lane.id);\n      return lane;\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: newLanes\n      }\n    });\n  },\n  paginateLane: (state, {\n    laneId,\n    newCards,\n    nextPage\n  }) => {\n    const updatedLanes = LaneHelper.appendCardsToLane(state, {\n      laneId: laneId,\n      newCards: newCards\n    });\n    updatedLanes.find(lane => lane.id === laneId).currentPage = nextPage;\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: updatedLanes\n      }\n    });\n  },\n  appendCardsToLane: (state, {\n    laneId,\n    newCards,\n    index\n  }) => {\n    const lane = state.lanes.find(lane => lane.id === laneId);\n    newCards = newCards.map(c => (0, _immutabilityHelper.default)(c, {\n      laneId: {\n        $set: laneId\n      }\n    })).filter(c => lane.cards.find(card => card.id === c.id) == null);\n    return state.lanes.map(lane => {\n      if (lane.id === laneId) {\n        if (index !== undefined) {\n          return (0, _immutabilityHelper.default)(lane, {\n            cards: {\n              $splice: [[index, 0, ...newCards]]\n            }\n          });\n        } else {\n          const cardsToUpdate = [...lane.cards, ...newCards];\n          return (0, _immutabilityHelper.default)(lane, {\n            cards: {\n              $set: cardsToUpdate\n            }\n          });\n        }\n      } else {\n        return lane;\n      }\n    });\n  },\n  appendCardToLane: (state, {\n    laneId,\n    card,\n    index\n  }) => {\n    const newLanes = LaneHelper.appendCardsToLane(state, {\n      laneId: laneId,\n      newCards: [card],\n      index\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: newLanes\n      }\n    });\n  },\n  addLane: (state, lane) => {\n    const newLane = (0, _objectSpread2.default)({\n      cards: []\n    }, lane);\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $push: [newLane]\n      }\n    });\n  },\n  updateLane: (state, updatedLane) => {\n    const newLanes = state.lanes.map(lane => {\n      if (updatedLane.id == lane.id) {\n        return (0, _objectSpread2.default)({}, lane, updatedLane);\n      } else {\n        return lane;\n      }\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: newLanes\n      }\n    });\n  },\n  removeCardFromLane: (state, {\n    laneId,\n    cardId\n  }) => {\n    const lanes = state.lanes.map(lane => {\n      if (lane.id === laneId) {\n        let newCards = lane.cards.filter(card => card.id !== cardId);\n        return (0, _immutabilityHelper.default)(lane, {\n          cards: {\n            $set: newCards\n          }\n        });\n      } else {\n        return lane;\n      }\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: lanes\n      }\n    });\n  },\n  updateCardFromLane: (state, {\n    laneId,\n    card\n  }) => {\n    const laneIndex = state.lanes.findIndex(x => x.id === laneId);\n\n    if (laneIndex < 0) {\n      return state;\n    }\n\n    const cardIndex = state.lanes[laneIndex].cards.findIndex(x => x.id === card.id);\n\n    if (cardIndex < 0) {\n      return state;\n    }\n\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        [laneIndex]: {\n          cards: {\n            [cardIndex]: {\n              $set: card\n            }\n          }\n        }\n      }\n    });\n  },\n  moveCardAcrossLanes: (state, {\n    fromLaneId,\n    toLaneId,\n    cardId,\n    index\n  }) => {\n    let cardToMove = null;\n    const interimLanes = state.lanes.map(lane => {\n      if (lane.id === fromLaneId) {\n        cardToMove = lane.cards.find(card => card.id === cardId);\n        const newCards = lane.cards.filter(card => card.id !== cardId);\n        return (0, _immutabilityHelper.default)(lane, {\n          cards: {\n            $set: newCards\n          }\n        });\n      } else {\n        return lane;\n      }\n    });\n    const updatedState = (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: interimLanes\n      }\n    });\n    return LaneHelper.appendCardToLane(updatedState, {\n      laneId: toLaneId,\n      card: cardToMove,\n      index: index\n    });\n  },\n  updateCardsForLane: (state, {\n    laneId,\n    cards\n  }) => {\n    const lanes = state.lanes.map(lane => {\n      if (lane.id === laneId) {\n        return (0, _immutabilityHelper.default)(lane, {\n          cards: {\n            $set: cards\n          }\n        });\n      } else {\n        return lane;\n      }\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: lanes\n      }\n    });\n  },\n  updateCardForLane: (state, {\n    laneId,\n    updatedCard\n  }) => {\n    const lanes = state.lanes.map(lane => {\n      if (lane.id === laneId) {\n        const cards = lane.cards.map(card => {\n          if (card.id === updatedCard.id) {\n            return (0, _objectSpread2.default)({}, card, updatedCard);\n          } else {\n            return card;\n          }\n        });\n        return (0, _immutabilityHelper.default)(lane, {\n          cards: {\n            $set: cards\n          }\n        });\n      } else {\n        return lane;\n      }\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: lanes\n      }\n    });\n  },\n  updateLanes: (state, lanes) => {\n    return (0, _objectSpread2.default)({}, state, {\n      lanes: lanes\n    });\n  },\n  moveLane: (state, {\n    oldIndex,\n    newIndex\n  }) => {\n    const laneToMove = state.lanes[oldIndex];\n    const tempState = (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $splice: [[oldIndex, 1]]\n      }\n    });\n    return (0, _immutabilityHelper.default)(tempState, {\n      lanes: {\n        $splice: [[newIndex, 0, laneToMove]]\n      }\n    });\n  },\n  removeLane: (state, {\n    laneId\n  }) => {\n    const updatedLanes = state.lanes.filter(lane => lane.id !== laneId);\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: updatedLanes\n      }\n    });\n  }\n};\nvar _default = LaneHelper;\nexports.default = _default;","map":{"version":3,"sources":["/Users/beminshaker/Downloads/stevens-planner/webapp/node_modules/react-trello/dist/helpers/LaneHelper.js"],"names":["_interopRequireDefault","require","Object","defineProperty","exports","value","default","_objectSpread2","_immutabilityHelper","LaneHelper","initialiseLanes","state","lanes","newLanes","map","lane","currentPage","cards","forEach","c","laneId","id","$set","paginateLane","newCards","nextPage","updatedLanes","appendCardsToLane","find","index","filter","card","undefined","$splice","cardsToUpdate","appendCardToLane","addLane","newLane","$push","updateLane","updatedLane","removeCardFromLane","cardId","updateCardFromLane","laneIndex","findIndex","x","cardIndex","moveCardAcrossLanes","fromLaneId","toLaneId","cardToMove","interimLanes","updatedState","updateCardsForLane","updateCardForLane","updatedCard","updateLanes","moveLane","oldIndex","newIndex","laneToMove","tempState","removeLane","_default"],"mappings":"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","sourcesContent":["\"use strict\";\n\nvar _interopRequireDefault = require(\"@babel/runtime/helpers/interopRequireDefault\");\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _objectSpread2 = _interopRequireDefault(require(\"@babel/runtime/helpers/objectSpread\"));\n\nvar _immutabilityHelper = _interopRequireDefault(require(\"immutability-helper\"));\n\nconst LaneHelper = {\n  initialiseLanes: (state, {\n    lanes\n  }) => {\n    const newLanes = lanes.map(lane => {\n      lane.currentPage = 1;\n      lane.cards && lane.cards.forEach(c => c.laneId = lane.id);\n      return lane;\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: newLanes\n      }\n    });\n  },\n  paginateLane: (state, {\n    laneId,\n    newCards,\n    nextPage\n  }) => {\n    const updatedLanes = LaneHelper.appendCardsToLane(state, {\n      laneId: laneId,\n      newCards: newCards\n    });\n    updatedLanes.find(lane => lane.id === laneId).currentPage = nextPage;\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: updatedLanes\n      }\n    });\n  },\n  appendCardsToLane: (state, {\n    laneId,\n    newCards,\n    index\n  }) => {\n    const lane = state.lanes.find(lane => lane.id === laneId);\n    newCards = newCards.map(c => (0, _immutabilityHelper.default)(c, {\n      laneId: {\n        $set: laneId\n      }\n    })).filter(c => lane.cards.find(card => card.id === c.id) == null);\n    return state.lanes.map(lane => {\n      if (lane.id === laneId) {\n        if (index !== undefined) {\n          return (0, _immutabilityHelper.default)(lane, {\n            cards: {\n              $splice: [[index, 0, ...newCards]]\n            }\n          });\n        } else {\n          const cardsToUpdate = [...lane.cards, ...newCards];\n          return (0, _immutabilityHelper.default)(lane, {\n            cards: {\n              $set: cardsToUpdate\n            }\n          });\n        }\n      } else {\n        return lane;\n      }\n    });\n  },\n  appendCardToLane: (state, {\n    laneId,\n    card,\n    index\n  }) => {\n    const newLanes = LaneHelper.appendCardsToLane(state, {\n      laneId: laneId,\n      newCards: [card],\n      index\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: newLanes\n      }\n    });\n  },\n  addLane: (state, lane) => {\n    const newLane = (0, _objectSpread2.default)({\n      cards: []\n    }, lane);\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $push: [newLane]\n      }\n    });\n  },\n  updateLane: (state, updatedLane) => {\n    const newLanes = state.lanes.map(lane => {\n      if (updatedLane.id == lane.id) {\n        return (0, _objectSpread2.default)({}, lane, updatedLane);\n      } else {\n        return lane;\n      }\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: newLanes\n      }\n    });\n  },\n  removeCardFromLane: (state, {\n    laneId,\n    cardId\n  }) => {\n    const lanes = state.lanes.map(lane => {\n      if (lane.id === laneId) {\n        let newCards = lane.cards.filter(card => card.id !== cardId);\n        return (0, _immutabilityHelper.default)(lane, {\n          cards: {\n            $set: newCards\n          }\n        });\n      } else {\n        return lane;\n      }\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: lanes\n      }\n    });\n  },\n  updateCardFromLane: (state, {\n    laneId,\n    card\n  }) => {\n    const laneIndex = state.lanes.findIndex(x => x.id === laneId);\n\n    if (laneIndex < 0) {\n      return state;\n    }\n\n    const cardIndex = state.lanes[laneIndex].cards.findIndex(x => x.id === card.id);\n\n    if (cardIndex < 0) {\n      return state;\n    }\n\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        [laneIndex]: {\n          cards: {\n            [cardIndex]: {\n              $set: card\n            }\n          }\n        }\n      }\n    });\n  },\n  moveCardAcrossLanes: (state, {\n    fromLaneId,\n    toLaneId,\n    cardId,\n    index\n  }) => {\n    let cardToMove = null;\n    const interimLanes = state.lanes.map(lane => {\n      if (lane.id === fromLaneId) {\n        cardToMove = lane.cards.find(card => card.id === cardId);\n        const newCards = lane.cards.filter(card => card.id !== cardId);\n        return (0, _immutabilityHelper.default)(lane, {\n          cards: {\n            $set: newCards\n          }\n        });\n      } else {\n        return lane;\n      }\n    });\n    const updatedState = (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: interimLanes\n      }\n    });\n    return LaneHelper.appendCardToLane(updatedState, {\n      laneId: toLaneId,\n      card: cardToMove,\n      index: index\n    });\n  },\n  updateCardsForLane: (state, {\n    laneId,\n    cards\n  }) => {\n    const lanes = state.lanes.map(lane => {\n      if (lane.id === laneId) {\n        return (0, _immutabilityHelper.default)(lane, {\n          cards: {\n            $set: cards\n          }\n        });\n      } else {\n        return lane;\n      }\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: lanes\n      }\n    });\n  },\n  updateCardForLane: (state, {\n    laneId,\n    updatedCard\n  }) => {\n    const lanes = state.lanes.map(lane => {\n      if (lane.id === laneId) {\n        const cards = lane.cards.map(card => {\n          if (card.id === updatedCard.id) {\n            return (0, _objectSpread2.default)({}, card, updatedCard);\n          } else {\n            return card;\n          }\n        });\n        return (0, _immutabilityHelper.default)(lane, {\n          cards: {\n            $set: cards\n          }\n        });\n      } else {\n        return lane;\n      }\n    });\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: lanes\n      }\n    });\n  },\n  updateLanes: (state, lanes) => {\n    return (0, _objectSpread2.default)({}, state, {\n      lanes: lanes\n    });\n  },\n  moveLane: (state, {\n    oldIndex,\n    newIndex\n  }) => {\n    const laneToMove = state.lanes[oldIndex];\n    const tempState = (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $splice: [[oldIndex, 1]]\n      }\n    });\n    return (0, _immutabilityHelper.default)(tempState, {\n      lanes: {\n        $splice: [[newIndex, 0, laneToMove]]\n      }\n    });\n  },\n  removeLane: (state, {\n    laneId\n  }) => {\n    const updatedLanes = state.lanes.filter(lane => lane.id !== laneId);\n    return (0, _immutabilityHelper.default)(state, {\n      lanes: {\n        $set: updatedLanes\n      }\n    });\n  }\n};\nvar _default = LaneHelper;\nexports.default = _default;"]},"metadata":{},"sourceType":"script"}